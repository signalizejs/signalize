<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta snippet="spa-cache-control" name="spa-cache-control" content="cache">
	<title snippet="title">Index page</title>
</head>

<body>
	<style>
		[cloak] {
			visibility: hidden;
		}
	</style>

	<script type="module">
		/* import Signalize from 'signalizejs';
		import directives from 'signalizejs/directives';
		import ifDirective from 'signalizejs/directives/if';
		import forDirective from 'signalizejs/directives/for'; */

		// Use the directives plugin
		/* const { component, on, signal, select, observeSignals, bind } = new Signalize({
			plugins: [
				directives(),
				ifDirective(),
				forDirective()
			]
		});
 */
		/* component('todo', {
			construct() {
				const count = signal(1000);
				const text = signal('');

				return {
					count,
					items: Object.entries({a: 2, b: 3}),
					text,
					label() {
						return `${this.i % 2 === 0 ? 'Even' : 'Odd'} ${this.i} -  ${text()}`
					},
					styleLabel() {
						return `color:${text().length > 2 ? 'red': 'blue'}`
					},
					isEven() {
						return this.i % 2 === 0
					},
					isOdd() {
						return this.i % 2 !== 0
					},
					oddText() {
						return 'Odd - ' + this.i + '-' + text
					},
					evenText() {
						return 'Even - ' + this.i + '-' + text
					},
					increment: () => count(count() + 1),
					decrement: () => count(count() - 1)
				}
			}
		}) */

		const evaluate = (str, context = {}) => {
			const chunkKeywordMap = {
				'undefined': undefined,
				'true': true,
				'false': false,
			}
			// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#table
			var precedenceOperatorsMap =  {
				//14: {
/* 					'++': (a) => ++a,
					'--': (a) => --a,
					'!': (a) => !!a,
					'!!': (a) => !!a,
					'typeof': (a) => typeof a,
*/
				//},
				13: {
					'**': (a, b) => a ** b,
				},
				12: {
					'*': (a, b) => a * b,
					'/': (a, b) => a / b,
					'%': (a, b) => a % b,
				},
				11: {
					'+': (a, b) => a + b,
					'-': (a, b) => a - b,
				},
 				9: {
					'<': (a, b) => a < b,
					'<=': (a, b) => a <= b,
					'>':  (a, b) => a > b,
					'>=': (a, b) => a >= b,
					in: (a, b) => a in b,
					instanceof: (a, b) => a instanceof b,
				},
				8: {
					'==': (a, b) => a === b ,
					'!=':  (a, b) => a !== b,
					'===': (a, b) => a === b,
					'!==': (a, b) => a !== b,
				},
				7: {
					'&':  (a, b) => a & b,
				},
				6: {
					'^': (a, b) => a ^ b,
				},
				5: {
					'|':  (a, b) => a | b,
				},
				4: {
					'&&': (a, b) => a && b,
				},
				3: {
					'||': (a, b) => a || b,
					'??': (a, b) => a ?? b,
				}
			};

			let operatorsKeys = [];

			for (const precedence in precedenceOperatorsMap) {
				operatorsKeys = [
					...operatorsKeys,
					...Object.keys(precedenceOperatorsMap[precedence])
				]
			}

			const parse = (str) => {
				const operatorsRe = new RegExp(`^(${operatorsKeys
					.map((item) => {
						return item.replace(/\|/g, '\\|')
						.replace(/\+/g, '\\+')
						.replace(/\//g, '\\/')
						.replace(/\?/g, '\\?')
						.replace(/\*/g, '\\*')
						.replace(/\^/, '\\^')
					})
					.sort((a, b) => b.length - a.length)
					.join('|')})`);
				const chunks = [];
				let inString = false;
				let inArgument = false;
				let tokensQueue = '';
				while(true) {
					const token = str[0];
					if (token === undefined) {
						break;
					}
					str = str.slice(1);
					tokensQueue += token;

					if (['"', "'"].includes(token)) {
						inString = !inString;
					}

					const operatorsDetected = operatorsRe.test(str);

					if (str[0] === undefined || (!inString && !inArgument && operatorsDetected)) {
						chunks.push(tokensQueue.trim());
						if (operatorsDetected) {
							str = str.replace(operatorsRe, (match) => {
								chunks.push(match.trim())
								return '';
							});
						}

						tokensQueue = '';
					}
				}
				return chunks;
			}

			const prepareChunk = (chunk) => {
				if (chunk in context) {
					// Todo, check, if it is a function, call it with arguments
					return context[chunk];
				}

				if (!Number.isNaN(parseFloat(chunk))) {
					return parseFloat(chunk);
				}

				if (["'", '"'].includes(chunk[0])) {chunk
					return chunk.substring(1).substring(0, chunk.length - 2);
				}

				if (chunk in chunkKeywordMap) {
					return chunkKeywordMap[chunk];
				}

				return chunk;
			}

			const execute = (precedences, chunks) => {
				const precedence = precedences.shift();

				if (precedence === undefined || chunks.length === 1) {
					return chunks[0];
				}

				const operators = precedenceOperatorsMap[precedence];
				let a;
				let b;
				let operator;
				let startIndex = 0;
				const chunksLength = chunks.length;

				while(startIndex <= chunksLength) {
					if (chunks[startIndex] in operators) {
						operator = chunks[startIndex];
						a = prepareChunk(chunks[startIndex + 1]);
						chunks[startIndex] = operators[operator](a);
						chunks.splice(startIndex + 1, 1);
					} else if (chunks[startIndex + 1] in operators) {
						a = prepareChunk(chunks[startIndex]);
						operator = chunks[startIndex + 1];
						b = prepareChunk(chunks[startIndex + 2]);
						chunks[startIndex] = operators[operator](a, b);
						chunks.splice(startIndex + 1, 2);
					} else {
						startIndex ++;
					}
				}

				return execute(precedences, chunks);
			}

			return execute(
				Object.keys(precedenceOperatorsMap).sort((a, b) => b - a),
				parse(str)
			);
		}

		const result = evaluate('a * 2 / 2.5', {
			a: 2,
			b: 4,
			c: 3
		});
		console.log(result)

	</script>

	<!-- <x-todo cloak>
		<input :value="text">
		<button @click="increment">Přidej<span :text="count"></span></button>
		<button @click="decrement">Odeber<span :text="count"></span></button><br>
		<ul>
			<template :for="i of count">
				<li>
					<template :if="isOdd">
						<span :text="oddText"></span>
					</template>
					<template :if="isEven">
						<span :text="evenText" :style="styleLabel"></span>
					</template>
				</li>
			</template>
		</ul>
	</x-todo> -->

	<!-- <div $count="1">
		<template :for="i of 1">
			<span :text="i"></span>
		</template>
		<div :id="count"></div>
	</div> -->

<!-- 	<div id="test" $code="'Hello World'">
		<div $fu="" scope="code">
		</div>
		<div :text="code"></div>
	</div> -->

	<!-- <input id="smaller" type="number">
	<input id="larger" type="number">

	<div id="sum"></div>
 -->
	<!-- Conditional loop for large amount of elements -->

<!-- 	<div scope $text="'Hello World!'" $count="1" cloak>
		<input :value="text">
		<button @click="count(count() + 1)">Přidej<span :text="count"></span></button>
		<button @click="count(count() - 1)">Odeber<span :text="count"></span></button><br>
		<ul>
			<template :for="i of count()">
				<li>
					<template :if="i % 2 !== 0">
						<span :text="'Odd' + i + ' - ' + text"></span>
					</template>
					<template :if="i % 2 === 0">
						<span :text="'Even' + i + ' - ' + text" :style="text().length > 2 ? 'color:red' : 'color:blue'"></span>
					</template>
				</li>
			</template>
		</ul>
	</div> -->

	<!-- <form $items="{}" $text="" @submit="
		event.preventDefault();
		items.set({...items(), [text()]: text()})
		text.set('');
	">
		<input :value="text">
		<ul>
			<template :for="item of Object.keys(items()).sort()">
				<li :key="item">
					<a
						role="button"
						@click="() => {
							const newItems = items();
							delete newItems[item()];
							items.set(newItems);
						}
						"
					>
						<span :text="item"></span> - X
					</a>
				</li>
			</template>
		</ul>
	</form> -->

	<!-- <template :for="[name, surname] of Object.entries({name: 'vladimir', surname: 'Macháček'})">
		<li :text="name + ' ' + surname"></li>
	</template> -->

	<!-- <div $items="[1,2]">
		<template :for="i of items">
			<div>
				<template :if="i % 2 !== 0">
					<li :text="'Odd - ' + items().length"></li>
				</template>
				<template :if="i % 2 === 0">
					<li :text="'Even - ' + items().length"></li>
				</template>
				<template :if="true"><div :text="'text'"></div></template>
			</div>
		</template>
	</div> -->

	 <!-- <div $items="[]">
		<button @click="items.set([items().length, ...items()])" :text="'+' + items().length"></button>
		<button @click="items.set(items().slice(1))" :text="'-' + items().length"></button>

		<template :for="i of items()">
			<div $text="i" :key="i"><input :value="text"><span :text="text"></span></div>
		</template>
	</div> -->

	<!-- <template :for="i in 1100">
		<div :text="i"></div>
	</template> -->
	<!-- 	<button $count="0" @click="count.set(count() + 1)">Count <span :text="count"></span></button>
 -->
	<!-- <div $text="'Longer'">
		<template :if="text().length < 2">
			<span>Shorter</span>
		</template>
		<template :if="text().length >= 2">
			<span>Meh</span>
		</template>
	</div> -->

	<!-- <div $meh="2">
		<div scope="counter" $count="0">
			<button @click="count.set(count() + 1)">Count <span :text="count"></span></button>
		</div>
	</div> -->

	<!-- <div $items="{
		birth: 0,
		label: 2
	}">
		<template :for="key in items">
			<div :html="key + ' - ' + items()[key]"></div>
		</template>
	</div>
 -->

</body>

</html>
